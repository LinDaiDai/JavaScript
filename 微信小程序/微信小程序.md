## 微信小程序



### 第一章: 基础标签



```
page -> 最大的标签body

view -> div
image -> img
rpx -> 响应式单位,可以根据屏幕的宽度进行自适应,动态的改变,规定屏幕宽为750rpx
bindtap -> vue中的@click
wx:if -> vue中的v-if
```



```
index.js中


Page({
  data: {	->vue中的data
    
  },
  //事件处理函数
  bindViewTap: function() {
    wx.navigateTo({			// 跳转的api
      url: '../logs/logs'
    })
  },
})
```



`app.js`中存放的是我们全局逻辑的文件,也就是我们全局的变量或者方法都可以放在这里.

```
app.js
{
  "pages": [	->引入不同的页面
      "pages/index/index",
      "pages/logs/logs",
      "pages/me/me",
      "pages/use/use"
  	],
  "tabBar": "tabBar": {
    "color": "#ff00ff",
    "list": [
      {
        "pagePath": "pages/index/index",	->点击跳转的页面路径
        "text": "收藏",					-> tabBar的名称
        "iconPath": "images/featured.png",	-> 为激活时图片
        "selectedIconPath": "images/featured-actived.png"  ->激活时图片
      },
      {
        "pagePath": "pages/logs/logs",
        "text": "搜索",
        "iconPath": "images/search.png",
        "selectedIconPath": "images/search-actived.png"
      },
      {
        "pagePath": "pages/me/me",
        "text": "我的...",
        "iconPath": "images/profile.png",
        "selectedIconPath": "images/profile-actived.png"
      },
      {
        "pagePath": "pages/use/use",
        "text": "日志",
        "iconPath": "images/usbox.png",
        "selectedIconPath": "images/usbox-actived.png"
      }
    ]
  },
  globalData: {		->vue中的vuex,react中的reduce
    userInfo: null
  }
}
```





`app.json`全局的配置都在这里





案例1:

在index.wxml中给text标签添加事件

```
  <view class="usermotto">
    <text class="user-motto" bindtap='changeMotto'>{{motto}}</text>	// 添加点击事件
  </view>
```

在index.js中添加方法

```
Page({
....
  changeMotto () {
    this.setData({			// 将数据修改为'hellow world'
      motto: 'hellow world'
    })
  }

})
```



### 第二章: 模块化



####2.1 全局变量

1.通过全局函数 [`getApp()`](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/app.html#getapp) 可以获取全局的应用实例，如果需要全局的数据可以在 `App()` 中设置:

```
// app.js
App({
  globalData: {	// 定义变量
  	num: 1,
  	name: 'myApp'
  }
  sayhellow () {	// 定义方法
  	console.log('hellow')
  }
})
```

2.使用

在要使用的页面,比如a.js中

```
var app = getApp()
console.log(app.globalData)
=> {num:1, name: 'myApp'}
```

也可以使用方法:

```
let app = getApp()
app.sayhellow()
=> hellow
```



上面我们是将sayhellow方法放在全局的应用实例,我们可以自定义一个模块进行引用.

如我在pages文件夹下创建文件夹common并编写common.js模块:

```
// common.js
function sayHello(name) {
  console.log(`Hello ${name} !`)
}
function sayGoodbye(name) {
  console.log(`Goodbye ${name} !`)
}

module.exports ={
  sayGoodbye: sayGoodbye,
  sayHello: sayHello
}
// export default {			// 或者用ES6导出模块的方式
//   sayGoodbye: sayGoodbye,
//   sayHello: sayHello
// }
```

在要使用的地方引用,如在use中使用:

```
var common = require('../common/common.js')
common.sayHello('USE')
common.sayGoodbye('USE')
=> HelloUSE
=> GoodbyeUSE
```

**注:require暂不支持绝对路径**	

#### 2.2 引用其他模块

小程序目前不支持直接引入 `node_modules` , 开发者需要使用到 `node_modules` 时候建议拷贝出相关的代码到小程序的目录中。

如我现在想要使用classnames这个模块,可以在utils文件夹下创建一个文件夹classnames,在其中执行:

```
cnpm i classnames
```

文件夹下多出node_modules,进入到里面,将东西全部移入到classnames中,然后在使用的地方引用,如在use.js

```
import cs from '../../utils/classnames/index.js'
console.log(cs('div1', {'active': true}))
=> div1 active
```



#### 2.3 WXS模块

WXS 代码可以编写在 wxml 文件中的 `<wxs>` 标签内，或以 `.wxs` 为后缀名的文件内



`<wxs>` 标签:

属性名: module

当前 `<wxs>` 标签的模块名。必填字段。

属性名:src

引用 .wxs 文件的相对路径。仅当本标签为**单闭合标签**或**标签的内容为空**时有效。

```
<wxs src="./../comm.wxs" module="comm" />
```





**在wxs标签内使用**	

1.如在me页面中:

```
me.wxml

<wxs module="m1">
	var msg = "hello world"
</wxs>
<view>{{m1.msg}}</view>

```



**使用.wxs文件**	

1.或者将wxs写入文件引用

```
comm.wxs

var foo = "'hello world' from comm.wxs";
var bar = function(d) {
  return d;
}
module.exports = {
  foo: foo,
  bar: bar
};
```

上述例子在 `comm.wxs` 的文件里面编写了 WXS 代码。该 `.wxs` 文件可以被其他的 `.wxs` 文件 或 WXML 中的 `<wxs>` 标签引用。

如在me中使用:

```
<wxs src="./../comm.wxs" module="comm" />
<view> {{comm.foo}} </view>
<view> {{comm.bar(comm.foo)}} </view>
```



**.wxs中使用其他.wxs文件**

在`.wxs`模块中引用其他 `wxs` 文件模块，可以使用 `require` 函数。



1.定义comm.wxs

```
comm.wxs

var foo = "'hello world' from comm.wxs";
var bar = function(d) {
  return d;
}
module.exports = {
  foo: foo,
  bar: bar
};
```

2.定义logic.wxs

```
logic.wxs

var tools = require("./comm.wxs");	// 引用comm.wxs

console.log(comm.foo);
console.log(comm.bar("logic.wxs"));
console.log(comm.msg);
```

3.在页面中使用logic.wxs,如在me中

```
me.wxml

<wxs src="./../logic.wxs" module="logic" />
```





### 第三章:事件



```
使用冒泡:
 bind:tap="tapName"		// 也可以连写bindtap
 
不使用冒泡:
catch:tap		// 也可以连写catchtap

捕获(并且冒泡):
capture-bind:tap

不捕获也不冒泡:
capture-catch:tap
```





## 第四章: 自定义组件



###4.1 基本写法

类似于页面，一个自定义组件由 `json` `wxml` `wxss` `js` 4个文件组成



在根目录创建一个文件夹component

创建一个叫price的组件,可以先创建一个名为price的文件夹,

分别创建4个文件



1.要在自定义的组件的.json文件中定义compoenent,表明他是一个组件

```
{
  "component": true
}
```



2.在wxml中编写:

```
<!-- 这是自定义组件的内部WXML结构 -->
<view class="inner">
  {{innerText}}
  <slot></slot>	<-- 插槽 -->
</view>
```

3.在wxss中编写:

```
/* 这里的样式只应用于这个自定义组件 */
.inner {
  color: red;
}
```

**注意：在组件wxss中不应使用ID选择器、属性选择器和标签名选择器。**

4.在js中编写

```
Component({
  properties: {
    // 这里定义了innerText属性，属性值可以在组件使用时指定(也就是传参传进来的属性)
    innerText: {
      type: String,
      value: 'default value',
    }
  },
  data: {
    // 这里是一些组件内部数据
    someData: {}
  },
  methods: {
    // 这里是一个自定义方法
    customMethod: function () { }
  }
})
```



5.使用上面的自定义组件,如在me页面中使用

​	1.在me.json中引入:

```
{
  "navigationBarTextStyle": "#fff",
  "navigationBarBackgroundColor": "#000",
  "navigationBarTitleText": "我的主页",
  "usingComponents": {
     "component-tag-name": "/component/price/price"
  }
}
```

​	2.在me.wxml中使用:

```
<view>  
  <!-- 以下是对一个自定义组件的引用 -->
  <component-tag-name inner-text="Some text">
  	<view>我是me中引用的price组件</view>
  </component-tag-name>
</view>
```



###4.2 slot

slot插槽

如在上面的例子中,在price.wxml中写入了<slot></slot>标签,在引用price这个组件时我们要是不在组件的标签中写入其他的内容,是不会显示<slot>标签的

也就是说如果我们把上面me.wxml改动一下:

```
<view>  
  <!-- 以下是对一个自定义组件的引用 -->
  <component-tag-name inner-text="Some text">
  </component-tag-name>
</view>
```

此时在me.wxml中只会渲染出

```
Some text
```



### 4.3 使用多个slot

正常情况下,一个组件中只有一个slot,也可以使用多个.

1.在price.js中配置:

```
Component({
  options: {
    multipleSlots: true // 在组件定义时的选项中启用多slot支持
  },
  properties: { /* ... */ },
  methods: { /* ... */ }
})
```

2.此时，可以在price这个组件的wxml中使用多个slot，以不同的 `name` 来区分。

```
<!-- 这是自定义组件的内部WXML结构 -->
<view class="inner">
  <slot name="before"></slot>
  <view>{{innerText}}</view>
  <slot name="after"></slot>
</view>
```

3.使用时，用 `slot` 属性来将节点插入到不同的slot上,如在me.wxml中

```
<view>  
  <!-- 以下是对一个自定义组件的引用 -->
  <component-tag-name inner-text="Some text">
    <!-- 这部分内容将被放置在组件 <slot name="before"> 的位置上 -->
    <view slot="before">这里是插入到组件slot name="before"中的内容</view>
    <!-- 这部分内容将被放置在组件 <slot name="after"> 的位置上 -->
    <view slot="after">这里是插入到组件slot name="after"中的内容</view>
  </component-tag-name>
</view>
```



### 4.4 behaviors

将几个组件中相同的属性或者方法提取出来写在behaviors中

每个 `behavior` 可以包含一组属性、数据、生命周期函数和方法，组件引用它时，它的属性、数据和方法会被合并到组件中，生命周期函数也会在对应时机被调用。每个组件可以引用多个 `behavior` 。 `behavior` 也可以引用其他 `behavior` 。

`behavior` 需要使用 `Behavior()` 构造器定义。

**一般在组件很多的情况下使用**



在根目录下创建behavior文件夹并编写:

```
// my-behavior.js
module.exports = Behavior({
  behaviors: [],
  properties: {
    myBehaviorProperty: {
      type: String
    }
  },
  data: {
    myBehaviorData: 'wpl'
  },
  attached: function () {},
  methods: {
    myBehaviorMethod: function () {
      console.log(this.data.myBehaviorData)	// 这里不能像vue一样直接写this.myBehaviorData
    }
  }
})
```



2.组件引用时，在 `behaviors` 定义段中将它们逐个列出即可,

如在price的组件中引用:

```
1. 引用
import MyBehaviors from '../../behaviors/my-behavior.js'
Component({
2. 列举
  behaviors: [MyBehaviors],
  options: {
    multipleSlots: true // 在组件定义时的选项中启用多slot支持
  },
  properties: {
    // 这里定义了innerText属性，属性值可以在组件使用时指定
    innerText: {
      type: String,
      value: 'default value',
    }
  },
  attached () {
3. 使用behaviors中的方法
    this.myBehaviorMethod()
    this.setData({
      someData: 2
    })
  },
  data: {
    // 这里是一些组件内部数据
    someData: 1
  },
  methods: {

  }
})
```

3.在组件页面中也能使用behaviors中的数据

如在price.wxml中:

```
<view class="inner">
  <slot name="header"></slot>
  {{innerText}}
  <slot name="footer"></slot>
  {{someData}}
  <view>这是混合自my-behavior中的data数据:{{myBehaviorData}}</view>	<-- 使用数据 -->
  <button bindtap="myBehaviorMethod">触发my-behavior中的myBehaviorMethod方法</button>
</view>
```



