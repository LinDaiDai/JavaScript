# 面试题



## 1.HTML

###1. 什么是HTML5?

> 首先,我们知道HTML5其实就是对HTML标准的第五次修改,我们广义上说的HTML5,实际是包过HTML,CSS,JavaScript在内的一套技术组合.
>
> 它的主要目标呢就是将互联网语义话,以便更好的被人类还有机器阅读,同时能够更好地支持各种媒体的嵌入,比如图片,链接,音乐等非文字元素.
>
> 我认为,它有俩大特点:首先,强化了web网页的表现性能.其次,追加了本地数据库等web应用的功能,提供了更多能支持网络应用的标准集.

**拓展:**

##### web数据库?

web数据库呢实际上就是以web查询接口方式访问的数据库资源,它将数据库技术和web技术融合在一起,使数据库成为了web的重要有机组成部分.

它的工作过程可以简单的描述成:用户通过浏览器的操作界面以交互的方式经由web服务器来访问数据库.

##### web?

万维网的简称web,

Web的工作步骤如下。

（1）用户打开客户端计算机中的浏览器软件（例如Internet Explorer）。

（2）用户输入要启动的Web主页的URL地址，浏览器将生成一个HTTP请求。

（3）浏览器连接到指定的Web服务器，并发送HTTP请求。

（4）Web服务器接到HTTP请求，根据请求的内容不同作相应的处理，再将网页以HTML文件格式发回给浏览器。

（5）浏览器将网页显示到屏幕上。

##### HTML语言?

超文本标记语言,就是创建网页的计算机语言  HTML(Hyper Text Markup Language)

我们所说的网页其实就是一个HTML文档,文档内容由文本和HTML标记组成,扩展名是.html或.htm

HTML标记:它的作用是告诉浏览器我们页面的结构和格式.如果将特定的英文单词放入标记中就是标签

HTML程序:放在<html></html>中,由文件头<head></head>和文件体<body></body>组成.

HTML规范:也就是HTML标准,是由W3C(万维网联盟)制定的.

HTML程序的编辑环境:任何文本编辑器.

HTML程序的运行环境:任何的浏览器

##### XML语言?

可拓展标记语言,是用来定义其它语言的一种元语言.

XML文档,由字符数据和标记组成.它的语义约束是DTD

##### DTD?

文档类型定义,基本格式:<!DOCTYPE 根元素[……规则……]>

我们知道浏览器解析css的俩种模式是: 标准模式和怪异模式

标准模式是指按w3c的标准解析执行代码,而怪异模式是指浏览器按它自己的方式解析执行.

而浏览器以哪种模式解释就是与你网页中的DTD声明有关.

若没有写DTD的话会使页面进入怪异模式.

##### HTML5不需要DTD?

因为HTML5没有使用SGML或者XHTML,是一个全新的东西,所以不需要参考DTD

##### HTML和XML区别?

 结构上大致相同,本质上不同:

1.语法要求不同,html中不区分大小写,xml中更严格.

2.标记不同,html使用固有的标记,xml没有固有的标记.

3.作用不同,html显示数据,xml描述数据,盛放数据.

**注:**

XML不是HTML的替代品,因为它们是俩种不同用途的语言.

##### .html? .htm?

.htm与.html没有本质上的区别,表示的是同一种文件,只是适用于不同的环境之下.DOS(磁盘操作系统)只能识别8 + 3的文件名,所以只能识别.htm而不能识别.html



### 2. HTML5与HTML4或更早的HTML的区别

1.文档声明上:html4比较复杂,而html5只有一小段`<!DOCTYPE html>`

2.结构语义上:html4没有体现语义化的标签,而html5有

3.同时h5又新添了很多表单元素的属性和类型

4.功能上HTML5更加强大,比如可以利用canvas标签配合js来实现绘图功能,也比如新增的视频标签video,以及新增的表单元素类型,像email,number,range,data等

##### H5新特性?

新增了27个元素,废弃了16个元素,

根据现有的标准规范,把HTML5的元素按照优先级定义为:

结构性元素,级块性元素行内语义性元素,交互性元素 4大类

结构性元素:主要负责web上下文结构的定义,比如像section,header,footer等等.

级块性元素:主要负责web页面区域的划分,比如像aside,figure,code等.

行内语义性元素:主要完成web页面具体内容的引用和描述,比如像meter,time,video等等.

交互性元素:主要用于功能性的内容表达,如menu,details等等.



##### H5的离线储存?

离线存储表示的是用户没有与因特网链接时,可以正常访问站点或应用.

原理是基于一个新建的.appcache文件的缓存机制,通过这个文件上的解析清单离线存储资源,这些资源就会像cookie一样被保存下来,当在没有网络的情况下,浏览器就会通过被离线存储的数据进行页面展示.

在我们H5中提供了俩种在客户端存储数据的新方法:

localStorage和sessionStorage

而在这之前呢,这些功能都是由cookie完成的,只不过cookie的存储量太小了最多也才4k,所以一适合大量数据的存储.

##### localStorage和sessionStorage?

它们俩都是H5新添的离线存储方法,并且两种方式保存的数据都仅限于该页面的协议,但不同之处在于:

localStorage它的存储没有时间限制,一周或者一个月一年,数据仍然存在.

而sessionStorage里面存储的数据会在浏览器会话结束时被清除

在兼容性上,各浏览器支持localStorage和sessionStorage的容量上限不同.在ie8以上是支持的,不包过ie8.

chrome4支持localStorage,chrome5支持sessionStorage.

##### cookie与它俩的区别?

第一点,在存储量上,cookie太小了.

第二点,cookie可以设置过期时间,但localStorage和sessionStorage没有提供设置过期时间的功能,但我们可以在存储的时候加上时间,以后在取值的时候判断一下localStorage是否过期就可以了.

##### 浏览器对离线存储的管理和加载?

在线状态下,浏览器要是发现html头部有manifest属性的话,它会请求manifast文件,若是第一次访问app,那么浏览器就会根据mainfest文件的内容下载对应的资源进行离线存储

离线状态下,已经访问过app并且资源已经离线存储了,那么浏览器就会使用离线的资源加载页面,然后浏览器会对比新的manifest文件与旧的manifest文件,如果文件没有发生改变,就不做任何操作,如果文件改变了,那么就会重新下载文件中的资源并进行离线存储.

#####userData?

ie支持userData存储数据.但是基本已经很少使用了,除非有很强的浏览器兼容需求.

##### 浏览器对H5的支持性?

在几个主流的浏览器中,比如ie浏览器,ie8以下是不支持的,ie9支持部分,比如video标签是支持的.ie10以上支持

还有像Chrome这样的高级浏览器,它的3-5支持大部分,在6以上就全部支持了.

##### H5中的form如何关闭自动完成功能?

我们知道,表单元素的自动完成功能就是输入框输入内容的时候,浏览器会从你以前的同名输入框的历史记录中查找出类似的内容并列举在输入框下面,当有时我们希望使用AJAX技术从数据库搜索并列举而不是根据浏览器的历史记录搜索,所以此时我们就需要将form的自动完成功能给关闭.

在ie浏览器下,我们可以在浏览器的设置中的internet选项菜单内容中将自动完成功能中的设置.

也可以在form标签中通过设置autocomplete为"on"或者"off"来开启或关闭自动完成功能.



### 3. a标签的四个伪类是什么?

a标签的四个伪类分别是未访问link,已访问visited,鼠标悬停hover,鼠标点击瞬间active

四个伪类的顺序是:分别是link,visited,hover,active.

其实link和visited的顺序其实是无所谓的,因为不可能同时触发未访问和已访问.

但是link是一定要在hover或者active之前.

visited要在hover之前.

而hover要在active之前.

关于兼容性的话,必须要在ie8包含ie8以上才有用.



### 4. HTML中文乱码

#####乱码原因?

第一点可能是因为没有设置HTML编码,也就是没有在meta标签中设置charset属性.

第二点也可能是使用了记事本编辑html,直接使用记事本编辑很容易造成html编码乱码

##### 怎么解决?

可以在meta标签中设置charset属性为"utf-8",另外尽量使用sublime等编辑器编辑代码,而不是用记事本.

###5. input属性有哪些？

input的属性目前在w3c上发布的是有23种,像比较常见的有定义输入字段的初始值value,规定输入字段为只读的readonly,还有规定字段禁用的disabled.

另外还有一些给input限制的标签,比如像size规定字段的尺寸,maxlength规定输入字段允许的最大长度

在我们H5中有给input添加了很多的属性,比如规定form自动完成功能的autocomplete,自动获取焦点的autofocus.

还有max和min规定元素的最大最小值等等.

##### input中readonly和disabled的区别

俩个都是表单的属性,都能做到使用户不能更改表单域中的内容.但他们也有一些差别.

第一点:readonly只针对type为text,password,textarea有效,而disabled对所有的表单元素都有效.

第二点:readonly可以进行表单提交,而disabled不能.

##### input的兼容性问题

首先在样式上,当type为text的时候,在ie浏览器下和在火狐等浏览器下高度不同,ie下为24px,火狐下为22px

type为submit也会不同.

同时在低版本的ie浏览器(ie8以下)下,input中的文本内容都会偏上一点.解决方案是给其添加padding-top.也可以给其设置高度和行高相等,但是在火狐下不行.

type为button时,value不能为空,否则它就不会和其他的表单元素头部对其,而是向上一些.解决方案:最后不要给value为空.







### 6.内联块元素有哪些?

常用的内联块元素有img标签,input标签

##### 内联块元素有哪些特征?

首先内联块元素是和块元素一样可以设置宽高的,但是却可以像内联元素一样放在同一行显示,代码空格换行也会被解析.

##### 内联块元素之间为什么会有小间隙?

那是因为内联元素的空格和换行会被解析

解决方案可以手动将回车空格给去除,但是这样会影响代码的美观,所以如果是像img这种不需要文本内容的内联块元素可以给它的父级的font-size设为0,也可以将它的宽高都设为100%.

#####png是

### 7. 如何优化网页

对于我们前端的网页优化来说,一方面是提高我们页面的加载速度,还一方面可能就是提高我们页面的表现性.

对于提高页面加载速度可以有这么几种方式:

1.减小Http请求的数量.

2.还可以运用css sprites技术将多个图片融合在一张大图上,另外也可以对图片进行压缩,比如png图片在www.tinypng.com上面进行压缩,然后在webpack进行转base64,只有图片大小不超过10k才会转.

3.使用CDN;

4.添加Expires头;

5.将样式表放在头部,减少页面首屏出现的时间,使内容逐步呈现,提高用户体验,可以防止"白屏"

6.将脚本放在底部,也是和样式表放在头部一样.因为js的下载会中断DOM的更新,所以script标签要是放在首屏范围内的HTML代码里是会截断首屏的内容的.另外也是为了保证脚本能按顺序执行.

7.避免css表达式

8.使用外部的javascript和css,因为当脚本或者css是从外部引用进来的时候,浏览器就有可能缓存它,在以后加载的时候就可以直接使用缓存.

9.减少DNS查找.

10.精简代码.

11.避免重定向.因为当页面发生了重定向的时候,就会影响整个HTML文档的传输.

12.使AJAX可缓存,也就是多用get而少用post,因为get是会在客户端进行缓存的,而post不会.

##### CDN?

CDN实际就是一组分布在不同地理位置的Web服务器,可以更加有效的像用户发布内容.

CDN还可以进行数据备份,扩展存储能力,进行缓存.

同时也是有一些缺点的,比如响应时间是会受到其他网站流量的影响,并且如果CDN服务质量下降了,你的工作质量也会下降,同时它也无法控制组件服务器.

#####Expires头?

当我们初次访问一个页面的时候,是会进行很多HTTP请求的,但是通过使用一个长久的Epires头,就可以使这些组件被缓存下来,下次访问的时候就可以减少不必要的HTTP请求.

#### 重定向与打开新页面

相同点:

都实现了根据自己的条件实现的页面的跳转

区别:

重定向导致浏览器发出了新的请求,在重定向之前存储为请求属性的任何对象都会消失,所以跳转到应用内的某个页面,没有浏览记录,而打开新页面不会这也是两者最大的区别.

所以使用重定向后,返回按钮会失效,除非在设置返回按钮时给它一个指定的路径.

为了提高网页的性能,应该避免重定向.

##### 重定向?

重定向是用户从一个URL重新路由到另一个URL.常用的重定向的类型有永久重定向,临时重定向.

永久重定向用于当网站的域名发生变更后,应该告诉搜索引擎域名已经变更了,从而不影响网站的排行.

而临时重定向主要是实现post请求之后告知浏览器转移到新的url,

应用的场景主要是

1.跟踪内部流量

2.跟踪出站流量

#####重定向如何损失性能的?

因为我们知道重定向其实就是用户从一个URL重新路由到另一个URL,所以就使浏览器发出了一个新的请求,这样是会延迟整个HTML文档的传输



### 8. ‘data-‘属性的作用是什么？

在介绍`data-`属性的作用之前我想先介绍一下`data-`,

data-属性是H5才新增的一种自定义属性,这些**属性**集可以通过对象的dataset**属性**获取,不支持该**属性**的浏览器可以通过 getAttribute方法获取

`在兼容性上`,dataset**属性**所有的主流浏览器都支持,但是在ie8一下包过ie8不支持.

为什么使用它呢,我们知道HTML标签是可以通过自定义属性来存储和操作数据的,但是这样在写法上就不太符合Html的规范,所以H5新添了这个自定义属性data



##2. css



###1. css代码压缩?

在以前是使用一些压缩工具进行手动压缩,但是现在我们都是直接使用webpack打包工具.

###2.三层嵌套?

在ie6是不支持border-radius的,当我们要在ie6下想做一个圆角就可以使用三层嵌套.但是在我们实际的开发中,要是只是为了达到一个圆角的效果而使用各种图片之类的有些太牵强了,所以在以前的开发中,我一般就是直接使用border-radius.

###3.页面可见性(Page Visibility)?

Page Visibility是H5新增的API

主要是用来判断用户是不是在与页面进行交互,也就是比如页面最小化了或者隐藏在其它标签页后面了,那么此时就可以用上我们的这个页面可见性.

这个API主要由三个部分组成:

第一个是document的hidden属性,表示页面是否隐藏的布尔值.

第二个是document的visibilityState属性,它有四个可能状态的值.

第三个是visibilitychange事件,当页面的可见性发生改变时会触发.

我们可以监听document的visibilitychange事件,当该事件触发时,获取document.hidden的值来对页面进行一些操作.比如隐藏页面时让播放的歌曲暂停等等.

##### 什么是页面隐藏?

页面的隐藏包过页面在后台标签页中或者浏览器最小化,

而页面被其他软件遮盖不算是隐藏

##### visibilityState?

visibilityState是判断页面状态的一个属性,有一下四个状态的值:

- hidden：页面在后台标签页中或者浏览器最小化
- visible：页面在前台标签页中
- prerender：页面在屏幕外执行预渲染处理 document.hidden 的值为 true
- unloaded：页面正在从内存中卸载

##### H5之前如何获取页面隐藏?

在H5之前,我们是靠监听document获取焦点和失去焦点来简单的认为页面是隐藏还是显示的.

### 4. hack?

在css中,hack是只一种兼容css在不同浏览器中正确显示的技巧.因为在不同的浏览器中,对css的解析认识不同,因此会导致生成的页面效果不同.这时候我们就需要针对不同的浏览器取写对应的css样式.一些常见的特殊符号的应用.

IE6认识的hacker 是下划线    **_**   和星号  *****

IE7能识别星号" * "，但不能识别下划线"_"，而firefox两个都不能认识。

### 5.解决display:inline-block;在ie6/7中不能正常显示

如果是块元素的话给它设置inline-block没有效果的,解决方案:

直接让块元素设置为内联对象呈现,也就是设置display: inline,然后在触发块元素的layout,比如设置zoom为1等.

其他的内联元素比如a标签,span标签是可以正常显示的.

##### layout?

layout是ie的一个私有概念,它决定了一个元素如何显示以及约束其包含的内容等等.一个元素是否具有"layot"属性可能会导致很多问题,比如ie中很多常见的浮动bug,容器与它子孙元素的边距重叠问题等等.

##### 如何触发layout?

给元素设置浮动,设置绝对定位,设置宽高,设置zoom,以及转换为inline-block,或者设置overflow等等都可以触发layout.

##### zomm?

是ie中网页缩放的比例

ie6/7下通过它来触发元素的hasLayout,解决大部分ie浏览器下的兼容问题.比如可以用来清除浮动,避免容器高度塌陷.

不过对于现在浏览器一般没必要用它了,因为它只在ie浏览器下有用.

### 6.清除浮动?

给父级float:left; 会影响后面的元素

给父级height:500px; 子级高度改变父级也要改变

给父级overflow:hidden;不同浏览器会有兼容性问题

给父级display:inline-block; 内联块的一堆问题还在 比如对齐之类的问题

给父级设置定位;

当然最好的办法就是在浮动元素的父级元素上使用伪类:after在其后面加上一个空元素并清除它的浮动就可以解决.



### 7.png图片有几种格式?

分别有3种不同深度的格式:png8,png24,png32

png8表示的是8位索引色位图.png24就是24位索引色位图

`在使用场景上`,因为png8最多只能显示256种颜色,就更适合那些颜色比较单一的图片,比如纯色,logo,图标等等.

而png24能显示的颜色要比png8多的多,大概能有1600万.

`显示效果上:`png8支持索引透明和alpha透明,而png24不支持透明,png32都支持.

`在兼容性上`:我们经常说的id6下不支持PNG透明,指的是不支持png24的透明,但是支持png8的透明,就像支持gif一样的透明一样.也就是在ie6下png24的图片的透明部分会被蒙上一层灰色.(解决方案



##### 索引色位图

计算机显示的图片中所使用的颜色,均有一个颜色体系,每一个颜色与一个颜色表对应出来,索引色常使用16色.32色等,最多不超过256色.

##### 切图是保存为什么样的格式

1.色彩丰富的,大的图片切为gif;

2.尺寸小,而且色彩不是很丰富和背景透明的切成gif或者png8;

3.而半透明的切为png24

### 8.两栏自适应布局，右侧div宽高不定	

比如左侧图片大小固定,右侧随父级宽度改变而改变



1.使用定位.

2.父级设定高度,子级高度100%,左侧图片大小固定并给左浮,右侧元素宽度给100%,因为左侧浮动了是压得住属性压不住内容的,所以如果有什么文字内容的是会环绕在图片周围,但是最好还是加一个margin-left,以避免右侧有背景图会被覆盖.

3.利用弹性布局,父级设定display: flex;左侧图片大小固定,右侧元素设定flex为1.

###9.响应式布局是什么？

 响应式布局就是界面能够适应不同的设备,不同的屏幕大小,让同一个页面在在不同的大小比例里看上去还是舒适的,不同分辨率上看上去还是合理的,不同的操作方式体验应该是统一的.

## 3.AJAX

### 1.ajax的事件？

ajaxComplete(callback)

ajaxError(callback)

ajaxSend(callback)

ajaxStart(callback)

ajaxStop(callback)

ajaxSuccess(callback)





## 函数

```
			function fun(n,o){
				console.log(o);
				return {
					fun:function(m){
						return fun(m,n);
					}
				}
			}
			// 第一次: 0, undefined   return {fun}
			// 第二次: 1, 0 console.log(0) n = 1; return {n:1}
			var a = fun(0).fun(1);
			// 第三次调用返回值中的fun方法同时传入2,也就是传入了m, 这个函数又是返回一个fun函数,也就是要打印出n,而n在第一次已经传入了是1,所以打印出1;
			a.fun(2);
			// 第四次和第三次一样,还是打印出n为1
			a.fun(3);
			// 第一次: 0, undefined console.log(undefined)
			// 第二次: 1, 0 console.log(0) n = 1; return {}
			// 第三次: 2, 1 console.log(1) n = 2; return {n:2}
			// 第四次: 3, 2 console.log(2) n = 3; return {n:3}
			var b = fun(0).fun(1).fun(2).fun(3);
			// 第一次: 0, undefined console.log(undefined)
			var c = fun(0);
			// 第二次: 1, 0 console.log(0)
			// 后面一样
			c.fun(1);
			c.fun(2);
			c.fun(3); 
```





-第二种是函数表达式 var一个变量赋值一个匿名函数`var foo = function () {}`

除此之外,要是第二种声明方式后接的不是一个匿名函数,则还是按第二种方式处理,也就是在函数外部无法通过这个函数的名访问到它.



FireBug WebInspector IETester Web Page Test 